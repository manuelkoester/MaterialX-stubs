"""Module containing Python bindings for the MaterialXCore library"""
from __future__ import annotations
import MaterialX.PyMaterialXCore
import typing

__all__ = [
    "ARRAY_PREFERRED_SEPARATOR",
    "ARRAY_VALID_SEPARATORS",
    "Backdrop",
    "Collection",
    "Color3",
    "Color4",
    "CommentElement",
    "DEFAULT_TYPE_STRING",
    "DISPLACEMENT_SHADER_TYPE_STRING",
    "Document",
    "Edge",
    "Element",
    "ElementPredicate",
    "Exception",
    "ExceptionFoundCycle",
    "ExceptionOrphanedElement",
    "FILENAME_TYPE_STRING",
    "GEOMNAME_TYPE_STRING",
    "GenericElement",
    "GeomElement",
    "GeomInfo",
    "GeomProp",
    "GeomPropDef",
    "GraphElement",
    "GraphIterator",
    "Implementation",
    "InheritanceIterator",
    "Input",
    "InterfaceElement",
    "LIGHT_SHADER_TYPE_STRING",
    "LinearUnitConverter",
    "Look",
    "LookGroup",
    "MATERIAL_TYPE_STRING",
    "MULTI_OUTPUT_TYPE_STRING",
    "MaterialAssign",
    "Matrix33",
    "Matrix44",
    "MatrixBase",
    "Member",
    "NAME_PATH_SEPARATOR",
    "NAME_PREFIX_SEPARATOR",
    "NONE_TYPE_STRING",
    "Node",
    "NodeDef",
    "NodeGraph",
    "NodePredicate",
    "Output",
    "PortElement",
    "Property",
    "PropertyAssign",
    "PropertySet",
    "PropertySetAssign",
    "SURFACE_MATERIAL_NODE_STRING",
    "SURFACE_SHADER_TYPE_STRING",
    "StringResolver",
    "Token",
    "TreeIterator",
    "TypeDef",
    "TypedElement",
    "TypedValue_boolean",
    "TypedValue_booleanarray",
    "TypedValue_color3",
    "TypedValue_color4",
    "TypedValue_float",
    "TypedValue_floatarray",
    "TypedValue_integer",
    "TypedValue_integerarray",
    "TypedValue_matrix33",
    "TypedValue_matrix44",
    "TypedValue_string",
    "TypedValue_stringarray",
    "TypedValue_vector2",
    "TypedValue_vector3",
    "TypedValue_vector4",
    "Unit",
    "UnitConverter",
    "UnitConverterRegistry",
    "UnitDef",
    "UnitTypeDef",
    "VALUE_STRING_FALSE",
    "VALUE_STRING_TRUE",
    "VOLUME_MATERIAL_NODE_STRING",
    "VOLUME_SHADER_TYPE_STRING",
    "Value",
    "ValueElement",
    "Variant",
    "VariantAssign",
    "VariantSet",
    "Vector2",
    "Vector3",
    "Vector4",
    "VectorBase",
    "Visibility",
    "createDocument",
    "createNamePath",
    "createValidName",
    "geomStringsMatch",
    "getConnectedOutputs",
    "getGeometryBindings",
    "getShaderNodes",
    "getVersionIntegers",
    "getVersionString",
    "incrementName",
    "isValidName",
    "parentNamePath",
    "prettyPrint",
    "replaceSubstrings",
    "splitNamePath",
    "splitString",
    "stringEndsWith",
    "targetStringsMatch"
]


class Element():
    def __eq__(self, arg0: Element) -> bool: ...
    def __ne__(self, arg0: Element) -> bool: ...
    def __str__(self) -> str: ...
    @staticmethod
    def _addChildCollection(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _addChildDocument(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _addChildGeomInfo(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _addChildGeomProp(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _addChildImplementation(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _addChildLook(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _addChildMaterialAssign(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _addChildNode(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _addChildNodeDef(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _addChildNodeGraph(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _addChildProperty(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _addChildPropertySet(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _addChildPropertySetAssign(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _addChildToken(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _addChildTypeDef(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _addChildVisibility(*args, **kwargs) -> typing.Any: ...
    def _getChild(self, arg0: str) -> Element: ...
    @staticmethod
    def _getChildOfTypeCollection(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _getChildOfTypeDocument(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _getChildOfTypeGeomInfo(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _getChildOfTypeGeomProp(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _getChildOfTypeImplementation(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _getChildOfTypeLook(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _getChildOfTypeMaterialAssign(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _getChildOfTypeNode(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _getChildOfTypeNodeDef(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _getChildOfTypeNodeGraph(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _getChildOfTypeProperty(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _getChildOfTypePropertySet(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _getChildOfTypePropertySetAssign(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _getChildOfTypeToken(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _getChildOfTypeTypeDef(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _getChildOfTypeVisibility(*args, **kwargs) -> typing.Any: ...
    def _getChildrenOfTypeCollection(self, category: str = '') -> typing.List[MaterialX::Collection]: ...
    def _getChildrenOfTypeDocument(self, category: str = '') -> typing.List[MaterialX::Document]: ...
    def _getChildrenOfTypeGeomInfo(self, category: str = '') -> typing.List[MaterialX::GeomInfo]: ...
    def _getChildrenOfTypeGeomProp(self, category: str = '') -> typing.List[MaterialX::GeomProp]: ...
    def _getChildrenOfTypeImplementation(self, category: str = '') -> typing.List[MaterialX::Implementation]: ...
    def _getChildrenOfTypeLook(self, category: str = '') -> typing.List[MaterialX::Look]: ...
    def _getChildrenOfTypeMaterialAssign(self, category: str = '') -> typing.List[MaterialX::MaterialAssign]: ...
    def _getChildrenOfTypeNode(self, category: str = '') -> typing.List[MaterialX::Node]: ...
    def _getChildrenOfTypeNodeDef(self, category: str = '') -> typing.List[MaterialX::NodeDef]: ...
    def _getChildrenOfTypeNodeGraph(self, category: str = '') -> typing.List[MaterialX::NodeGraph]: ...
    def _getChildrenOfTypeProperty(self, category: str = '') -> typing.List[MaterialX::Property]: ...
    def _getChildrenOfTypePropertySet(self, category: str = '') -> typing.List[MaterialX::PropertySet]: ...
    def _getChildrenOfTypePropertySetAssign(self, category: str = '') -> typing.List[MaterialX::PropertySetAssign]: ...
    def _getChildrenOfTypeToken(self, category: str = '') -> typing.List[MaterialX::Token]: ...
    def _getChildrenOfTypeTypeDef(self, category: str = '') -> typing.List[MaterialX::TypeDef]: ...
    def _getChildrenOfTypeVisibility(self, category: str = '') -> typing.List[MaterialX::Visibility]: ...
    def _removeChildOfTypeCollection(self, arg0: str) -> None: ...
    def _removeChildOfTypeDocument(self, arg0: str) -> None: ...
    def _removeChildOfTypeGeomInfo(self, arg0: str) -> None: ...
    def _removeChildOfTypeGeomProp(self, arg0: str) -> None: ...
    def _removeChildOfTypeImplementation(self, arg0: str) -> None: ...
    def _removeChildOfTypeLook(self, arg0: str) -> None: ...
    def _removeChildOfTypeMaterialAssign(self, arg0: str) -> None: ...
    def _removeChildOfTypeNode(self, arg0: str) -> None: ...
    def _removeChildOfTypeNodeDef(self, arg0: str) -> None: ...
    def _removeChildOfTypeNodeGraph(self, arg0: str) -> None: ...
    def _removeChildOfTypeProperty(self, arg0: str) -> None: ...
    def _removeChildOfTypePropertySet(self, arg0: str) -> None: ...
    def _removeChildOfTypePropertySetAssign(self, arg0: str) -> None: ...
    def _removeChildOfTypeToken(self, arg0: str) -> None: ...
    def _removeChildOfTypeTypeDef(self, arg0: str) -> None: ...
    def _removeChildOfTypeVisibility(self, arg0: str) -> None: ...
    def addChildOfCategory(self, category: str, name: str = '') -> Element: ...
    def asString(self) -> str: ...
    def changeChildCategory(self, arg0: Element, arg1: str) -> Element: ...
    def clearContent(self) -> None: ...
    def copyContentFrom(self, arg0: Element) -> None: ...
    @staticmethod
    def createStringResolver(*args, **kwargs) -> typing.Any: ...
    def createValidChildName(self, arg0: str) -> str: ...
    def getActiveColorSpace(self) -> str: ...
    def getActiveFilePrefix(self) -> str: ...
    def getActiveGeomPrefix(self) -> str: ...
    def getActiveSourceUri(self) -> str: ...
    def getAttribute(self, arg0: str) -> str: ...
    def getAttributeNames(self) -> typing.List[str]: ...
    def getCategory(self) -> str: ...
    def getChildIndex(self, arg0: str) -> int: ...
    def getChildren(self) -> typing.List[Element]: ...
    def getColorSpace(self) -> str: ...
    def getDocString(self) -> str: ...
    @staticmethod
    def getDocument(*args, **kwargs) -> typing.Any: ...
    def getFilePrefix(self) -> str: ...
    def getGeomPrefix(self) -> str: ...
    def getInheritString(self) -> str: ...
    def getInheritsFrom(self) -> Element: ...
    def getName(self) -> str: ...
    def getNamePath(self, relativeTo: Element = None) -> str: ...
    def getNamespace(self) -> str: ...
    def getParent(self) -> Element: ...
    def getQualifiedName(self, arg0: str) -> str: ...
    def getRoot(self) -> Element: ...
    def getSelf(self) -> Element: ...
    def getSourceUri(self) -> str: ...
    @staticmethod
    def getUpstreamEdge(*args, **kwargs) -> typing.Any: ...
    def getUpstreamEdgeCount(self) -> int: ...
    def getUpstreamElement(self, index: int = 0) -> Element: ...
    def hasAttribute(self, arg0: str) -> bool: ...
    def hasColorSpace(self) -> bool: ...
    def hasFilePrefix(self) -> bool: ...
    def hasGeomPrefix(self) -> bool: ...
    def hasInheritString(self) -> bool: ...
    def hasInheritanceCycle(self) -> bool: ...
    def hasInheritedBase(self, arg0: Element) -> bool: ...
    def hasNamespace(self) -> bool: ...
    def hasSourceUri(self) -> bool: ...
    def removeAttribute(self, arg0: str) -> None: ...
    def removeChild(self, arg0: str) -> None: ...
    def setAttribute(self, arg0: str, arg1: str) -> None: ...
    def setCategory(self, arg0: str) -> None: ...
    def setChildIndex(self, arg0: str, arg1: int) -> None: ...
    def setColorSpace(self, arg0: str) -> None: ...
    def setDocString(self, arg0: str) -> None: ...
    def setFilePrefix(self, arg0: str) -> None: ...
    def setGeomPrefix(self, arg0: str) -> None: ...
    def setInheritString(self, arg0: str) -> None: ...
    def setInheritsFrom(self, arg0: Element) -> None: ...
    def setName(self, arg0: str) -> None: ...
    def setNamespace(self, arg0: str) -> None: ...
    def setSourceUri(self, arg0: str) -> None: ...
    @staticmethod
    def traverseGraph(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def traverseInheritance(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def traverseTree(*args, **kwargs) -> typing.Any: ...
    def validate(self) -> typing.Tuple[bool, str]: ...
    pass
class Collection(Element):
    def getExcludeGeom(self) -> str: ...
    def getIncludeCollectionString(self) -> str: ...
    def getIncludeCollections(self) -> typing.List[Collection]: ...
    def getIncludeGeom(self) -> str: ...
    def hasExcludeGeom(self) -> bool: ...
    def hasIncludeCollectionString(self) -> bool: ...
    def hasIncludeCycle(self) -> bool: ...
    def hasIncludeGeom(self) -> bool: ...
    def matchesGeomString(self, arg0: str) -> bool: ...
    def setExcludeGeom(self, arg0: str) -> None: ...
    def setIncludeCollection(self, arg0: Collection) -> None: ...
    def setIncludeCollectionString(self, arg0: str) -> None: ...
    def setIncludeCollections(self, arg0: typing.List[Collection]) -> None: ...
    def setIncludeGeom(self, arg0: str) -> None: ...
    CATEGORY = 'collection'
    pass
class VectorBase():
    pass
class Color4(VectorBase):
    def __add__(self, arg0: Color4) -> Color4: ...
    def __eq__(self, arg0: Color4) -> bool: ...
    def __getitem__(self, arg0: int) -> float: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: float) -> None: ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float) -> None: ...
    @typing.overload
    def __init__(self, arg0: typing.List[float[4]]) -> None: ...
    @typing.overload
    def __init__(self, arg0: typing.List[float]) -> None: ...
    @staticmethod
    def __len__() -> int: ...
    @typing.overload
    def __mul__(self, arg0: Color4) -> Color4: ...
    @typing.overload
    def __mul__(self, arg0: float) -> Color4: ...
    def __ne__(self, arg0: Color4) -> bool: ...
    def __setitem__(self, arg0: int, arg1: float) -> None: ...
    def __str__(self) -> str: ...
    def __sub__(self, arg0: Color4) -> Color4: ...
    @typing.overload
    def __truediv__(self, arg0: Color4) -> Color4: ...
    @typing.overload
    def __truediv__(self, arg0: float) -> Color4: ...
    def asTuple(self) -> typing.Tuple[float, float, float, float]: ...
    def copy(self) -> Color4: ...
    def dot(self, arg0: Color4) -> float: ...
    def getMagnitude(self) -> float: ...
    def getNormalized(self) -> Color4: ...
    pass
class CommentElement(Element):
    CATEGORY = 'comment'
    pass
class TypedElement(Element):
    def getType(self) -> str: ...
    @staticmethod
    def getTypeDef(*args, **kwargs) -> typing.Any: ...
    def hasType(self) -> bool: ...
    def isMultiOutputType(self) -> bool: ...
    def setType(self, arg0: str) -> None: ...
    TYPE_ATTRIBUTE = 'type'
    pass
class Edge():
    def getConnectingElement(self) -> Element: ...
    def getDownstreamElement(self) -> Element: ...
    def getName(self) -> str: ...
    def getUpstreamElement(self) -> Element: ...
    pass
class Backdrop(Element):
    def getContainsElements(self) -> typing.List[TypedElement]: ...
    def getContainsString(self) -> str: ...
    def getHeight(self) -> float: ...
    def getWidth(self) -> float: ...
    def hasContainsString(self) -> bool: ...
    def hasHeight(self) -> bool: ...
    def hasWidth(self) -> bool: ...
    def setContainsElements(self, arg0: typing.List[TypedElement]) -> None: ...
    def setContainsString(self, arg0: str) -> None: ...
    def setHeight(self, arg0: float) -> None: ...
    def setWidth(self, arg0: float) -> None: ...
    CATEGORY = 'backdrop'
    CONTAINS_ATTRIBUTE = 'contains'
    HEIGHT_ATTRIBUTE = 'height'
    WIDTH_ATTRIBUTE = 'width'
    pass
class ElementPredicate():
    pass
class Exception(BaseException):
    pass
class ExceptionFoundCycle(Exception, BaseException):
    pass
class ExceptionOrphanedElement(Exception, BaseException):
    pass
class GenericElement(Element):
    CATEGORY = 'generic'
    pass
class GeomElement(Element):
    @staticmethod
    def getCollection(*args, **kwargs) -> typing.Any: ...
    def getCollectionString(self) -> str: ...
    def getGeom(self) -> str: ...
    def hasCollectionString(self) -> bool: ...
    def hasGeom(self) -> bool: ...
    @staticmethod
    def setCollection(*args, **kwargs) -> typing.Any: ...
    def setCollectionString(self, arg0: str) -> None: ...
    def setGeom(self, arg0: str) -> None: ...
    pass
class GeomInfo(GeomElement, Element):
    @staticmethod
    def _setGeomPropValueboolean(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _setGeomPropValuebooleanarray(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _setGeomPropValuecolor3(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _setGeomPropValuecolor4(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _setGeomPropValuefloat(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _setGeomPropValuefloatarray(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _setGeomPropValueinteger(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _setGeomPropValueintegerarray(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _setGeomPropValuematrix33(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _setGeomPropValuematrix44(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _setGeomPropValuestring(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _setGeomPropValuestringarray(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _setGeomPropValuevector2(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _setGeomPropValuevector3(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _setGeomPropValuevector4(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def addGeomProp(*args, **kwargs) -> typing.Any: ...
    def addToken(self, name: str = 'color3') -> Token: ...
    @staticmethod
    def getGeomProp(*args, **kwargs) -> typing.Any: ...
    def getGeomProps(self) -> typing.List[MaterialX::GeomProp]: ...
    def getToken(self, arg0: str) -> Token: ...
    def getTokens(self) -> typing.List[Token]: ...
    def removeGeomProp(self, arg0: str) -> None: ...
    def removeToken(self, arg0: str) -> None: ...
    def setTokenValue(self, arg0: str, arg1: str) -> Token: ...
    CATEGORY = 'geominfo'
    pass
class ValueElement(TypedElement, Element):
    @staticmethod
    def _getDefaultValue(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _getValue(*args, **kwargs) -> typing.Any: ...
    def _setValueboolean(self, value: bool, type: str = '') -> None: ...
    def _setValuebooleanarray(self, value: typing.List[bool], type: str = '') -> None: ...
    @staticmethod
    def _setValuecolor3(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _setValuecolor4(*args, **kwargs) -> typing.Any: ...
    def _setValuefloat(self, value: float, type: str = '') -> None: ...
    def _setValuefloatarray(self, value: typing.List[float], type: str = '') -> None: ...
    def _setValueinteger(self, value: int, type: str = '') -> None: ...
    def _setValueintegerarray(self, value: typing.List[int], type: str = '') -> None: ...
    @staticmethod
    def _setValuematrix33(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _setValuematrix44(*args, **kwargs) -> typing.Any: ...
    def _setValuestring(self, value: str, type: str = '') -> None: ...
    def _setValuestringarray(self, value: typing.List[str], type: str = '') -> None: ...
    @staticmethod
    def _setValuevector2(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _setValuevector3(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _setValuevector4(*args, **kwargs) -> typing.Any: ...
    def getActiveUnit(self) -> str: ...
    def getImplementationName(self) -> str: ...
    def getInterfaceName(self) -> str: ...
    def getIsUniform(self) -> bool: ...
    @staticmethod
    def getResolvedValueString(*args, **kwargs) -> typing.Any: ...
    def getUnit(self) -> str: ...
    def getUnitType(self) -> str: ...
    def getValueString(self) -> str: ...
    def hasImplementationName(self) -> bool: ...
    def hasInterfaceName(self) -> bool: ...
    def hasUnit(self) -> bool: ...
    def hasUnitType(self) -> bool: ...
    def hasValueString(self) -> bool: ...
    def setImplementationName(self, arg0: str) -> None: ...
    def setInterfaceName(self, arg0: str) -> None: ...
    def setIsUniform(self, arg0: bool) -> None: ...
    def setUnit(self, arg0: str) -> None: ...
    def setUnitType(self, arg0: str) -> None: ...
    def setValueString(self, arg0: str) -> None: ...
    ENUM_ATTRIBUTE = 'enum'
    ENUM_VALUES_ATTRIBUTE = 'enumvalues'
    IMPLEMENTATION_NAME_ATTRIBUTE = 'implname'
    IMPLEMENTATION_TYPE_ATTRIBUTE = 'impltype'
    INTERFACE_NAME_ATTRIBUTE = 'interfacename'
    TYPE_ATTRIBUTE = 'type'
    UI_ADVANCED_ATTRIBUTE = 'uiadvanced'
    UI_FOLDER_ATTRIBUTE = 'uifolder'
    UI_MAX_ATTRIBUTE = 'uimax'
    UI_MIN_ATTRIBUTE = 'uimin'
    UI_NAME_ATTRIBUTE = 'uiname'
    UI_SOFT_MAX_ATTRIBUTE = 'uisoftmax'
    UI_SOFT_MIN_ATTRIBUTE = 'uisoftmin'
    UI_STEP_ATTRIBUTE = 'uistep'
    UNIT_ATTRIBUTE = 'unit'
    VALUE_ATTRIBUTE = 'value'
    pass
class GeomPropDef(Element):
    def getGeomProp(self) -> str: ...
    def getIndex(self) -> str: ...
    def getSpace(self) -> str: ...
    def hasGeomProp(self) -> bool: ...
    def hasIndex(self) -> bool: ...
    def hasSpace(self) -> bool: ...
    def setGeomProp(self, arg0: str) -> None: ...
    def setIndex(self, arg0: str) -> None: ...
    def setSpace(self, arg0: str) -> None: ...
    CATEGORY = 'geompropdef'
    pass
class InterfaceElement(TypedElement, Element):
    @staticmethod
    def _getInputValue(*args, **kwargs) -> typing.Any: ...
    def _setInputValueboolean(self, name: str, value: bool, type: str = '') -> Input: ...
    def _setInputValuebooleanarray(self, name: str, value: typing.List[bool], type: str = '') -> Input: ...
    @staticmethod
    def _setInputValuecolor3(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _setInputValuecolor4(*args, **kwargs) -> typing.Any: ...
    def _setInputValuefloat(self, name: str, value: float, type: str = '') -> Input: ...
    def _setInputValuefloatarray(self, name: str, value: typing.List[float], type: str = '') -> Input: ...
    def _setInputValueinteger(self, name: str, value: int, type: str = '') -> Input: ...
    def _setInputValueintegerarray(self, name: str, value: typing.List[int], type: str = '') -> Input: ...
    @staticmethod
    def _setInputValuematrix33(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _setInputValuematrix44(*args, **kwargs) -> typing.Any: ...
    def _setInputValuestring(self, name: str, value: str, type: str = '') -> Input: ...
    def _setInputValuestringarray(self, name: str, value: typing.List[str], type: str = '') -> Input: ...
    @staticmethod
    def _setInputValuevector2(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _setInputValuevector3(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _setInputValuevector4(*args, **kwargs) -> typing.Any: ...
    def addInput(self, name: str = '', type: str = 'color3') -> Input: ...
    def addOutput(self, name: str = '', type: str = 'color3') -> Output: ...
    def addToken(self, name: str = 'color3') -> Token: ...
    def getActiveInput(self, arg0: str) -> Input: ...
    def getActiveInputs(self) -> typing.List[Input]: ...
    def getActiveOutput(self, arg0: str) -> Output: ...
    def getActiveOutputs(self) -> typing.List[Output]: ...
    def getActiveToken(self, arg0: str) -> Token: ...
    def getActiveTokens(self) -> typing.List[Token]: ...
    def getActiveValueElement(self, arg0: str) -> ValueElement: ...
    def getActiveValueElements(self) -> typing.List[ValueElement]: ...
    def getConnectedOutput(self, arg0: str) -> Output: ...
    @staticmethod
    def getDeclaration(*args, **kwargs) -> typing.Any: ...
    def getDefaultVersion(self) -> bool: ...
    def getInput(self, arg0: str) -> Input: ...
    def getInputCount(self) -> int: ...
    def getInputs(self) -> typing.List[Input]: ...
    def getNodeDefString(self) -> str: ...
    def getOutput(self, arg0: str) -> Output: ...
    def getOutputCount(self) -> int: ...
    def getOutputs(self) -> typing.List[Output]: ...
    def getTarget(self) -> str: ...
    def getToken(self, arg0: str) -> Token: ...
    def getTokenValue(self, arg0: str) -> str: ...
    def getTokens(self) -> typing.List[Token]: ...
    def getVersionIntegers(self) -> typing.Tuple[int, int]: ...
    def getVersionString(self) -> str: ...
    def hasNodeDefString(self) -> bool: ...
    def hasTarget(self) -> bool: ...
    def hasVersionString(self) -> bool: ...
    def isTypeCompatible(self, arg0: InterfaceElement) -> bool: ...
    def removeInput(self, arg0: str) -> None: ...
    def removeOutput(self, arg0: str) -> None: ...
    def removeToken(self, arg0: str) -> None: ...
    def setConnectedOutput(self, arg0: str, arg1: Output) -> None: ...
    def setDefaultVersion(self, arg0: bool) -> None: ...
    def setNodeDefString(self, arg0: str) -> None: ...
    def setTarget(self, arg0: str) -> None: ...
    def setTokenValue(self, arg0: str, arg1: str) -> Token: ...
    def setVersionIntegers(self, arg0: int, arg1: int) -> None: ...
    def setVersionString(self, arg0: str) -> None: ...
    NODE_DEF_ATTRIBUTE = 'nodedef'
    TYPE_ATTRIBUTE = 'type'
    pass
class GraphIterator():
    def __iter__(self) -> GraphIterator: ...
    def __next__(self) -> Edge: ...
    def getConnectingElement(self) -> Element: ...
    def getDownstreamElement(self) -> Element: ...
    def getElementDepth(self) -> int: ...
    def getNodeDepth(self) -> int: ...
    def getPruneSubgraph(self) -> bool: ...
    def getUpstreamElement(self) -> Element: ...
    def getUpstreamIndex(self) -> int: ...
    def setPruneSubgraph(self, arg0: bool) -> None: ...
    pass
class Implementation(InterfaceElement, TypedElement, Element):
    def getFile(self) -> str: ...
    def getFunction(self) -> str: ...
    def getNodeDef(self) -> NodeDef: ...
    def hasFile(self) -> bool: ...
    def hasFunction(self) -> bool: ...
    def setFile(self, arg0: str) -> None: ...
    def setFunction(self, arg0: str) -> None: ...
    def setNodeDef(self, arg0: NodeDef) -> None: ...
    CATEGORY = 'implementation'
    FILE_ATTRIBUTE = 'file'
    FUNCTION_ATTRIBUTE = 'function'
    NODE_DEF_ATTRIBUTE = 'nodedef'
    TYPE_ATTRIBUTE = 'type'
    pass
class InheritanceIterator():
    def __iter__(self) -> InheritanceIterator: ...
    def __next__(self) -> Element: ...
    pass
class PortElement(ValueElement, TypedElement, Element):
    def getChannels(self) -> str: ...
    @staticmethod
    def getConnectedNode(*args, **kwargs) -> typing.Any: ...
    def getNodeGraphString(self) -> str: ...
    def getNodeName(self) -> str: ...
    def getOutputString(self) -> str: ...
    def hasNodeGraphString(self) -> bool: ...
    def hasOutputString(self) -> bool: ...
    def setChannels(self, arg0: str) -> None: ...
    @staticmethod
    def setConnectedNode(*args, **kwargs) -> typing.Any: ...
    def setNodeGraphString(self, arg0: str) -> None: ...
    def setNodeName(self, arg0: str) -> None: ...
    def setOutputString(self, arg0: str) -> None: ...
    ENUM_ATTRIBUTE = 'enum'
    ENUM_VALUES_ATTRIBUTE = 'enumvalues'
    IMPLEMENTATION_NAME_ATTRIBUTE = 'implname'
    IMPLEMENTATION_TYPE_ATTRIBUTE = 'impltype'
    INTERFACE_NAME_ATTRIBUTE = 'interfacename'
    TYPE_ATTRIBUTE = 'type'
    UI_ADVANCED_ATTRIBUTE = 'uiadvanced'
    UI_FOLDER_ATTRIBUTE = 'uifolder'
    UI_MAX_ATTRIBUTE = 'uimax'
    UI_MIN_ATTRIBUTE = 'uimin'
    UI_NAME_ATTRIBUTE = 'uiname'
    UI_SOFT_MAX_ATTRIBUTE = 'uisoftmax'
    UI_SOFT_MIN_ATTRIBUTE = 'uisoftmin'
    UI_STEP_ATTRIBUTE = 'uistep'
    UNIT_ATTRIBUTE = 'unit'
    VALUE_ATTRIBUTE = 'value'
    pass
class GraphElement(InterfaceElement, TypedElement, Element):
    @staticmethod
    def addBackdrop(*args, **kwargs) -> typing.Any: ...
    def addMaterialNode(self, name: str = '', shaderNode: Node = None) -> Node: ...
    def addNode(self, category: str, name: str = '', type: str = 'color3') -> Node: ...
    def addNodeInstance(self, nodeDef: NodeDef, name: str = '') -> Node: ...
    def asStringDot(self) -> str: ...
    def flattenSubgraphs(self, target: str = '', filter: NodePredicate = None) -> None: ...
    @staticmethod
    def getBackdrop(*args, **kwargs) -> typing.Any: ...
    def getBackdrops(self) -> typing.List[MaterialX::Backdrop]: ...
    def getMaterialNodes(self) -> typing.List[Node]: ...
    def getNode(self, arg0: str) -> Node: ...
    def getNodes(self, category: str = '') -> typing.List[Node]: ...
    def removeBackdrop(self, arg0: str) -> None: ...
    def removeNode(self, arg0: str) -> None: ...
    def topologicalSort(self) -> typing.List[Element]: ...
    NODE_DEF_ATTRIBUTE = 'nodedef'
    TYPE_ATTRIBUTE = 'type'
    pass
class UnitConverter():
    @typing.overload
    def convert(self, arg0: Vector2, arg1: str, arg2: str) -> Vector2: ...
    @typing.overload
    def convert(self, arg0: Vector3, arg1: str, arg2: str) -> Vector3: ...
    @typing.overload
    def convert(self, arg0: Vector4, arg1: str, arg2: str) -> Vector4: ...
    @typing.overload
    def convert(self, arg0: float, arg1: str, arg2: str) -> float: ...
    def getUnitAsInteger(self, arg0: str) -> int: ...
    def getUnitFromInteger(self, arg0: int) -> str: ...
    pass
class Look(Element):
    @staticmethod
    def addMaterialAssign(*args, **kwargs) -> typing.Any: ...
    def addPropertyAssign(self, name: str = '') -> PropertyAssign: ...
    def addPropertySetAssign(self, name: str = '') -> PropertySetAssign: ...
    @staticmethod
    def addVariantAssign(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def addVisibility(*args, **kwargs) -> typing.Any: ...
    def getActiveMaterialAssigns(self) -> typing.List[MaterialX::MaterialAssign]: ...
    def getActivePropertyAssigns(self) -> typing.List[PropertyAssign]: ...
    def getActivePropertySetAssigns(self) -> typing.List[PropertySetAssign]: ...
    def getActiveVariantAssigns(self) -> typing.List[MaterialX::VariantAssign]: ...
    def getActiveVisibilities(self) -> typing.List[MaterialX::Visibility]: ...
    @staticmethod
    def getMaterialAssign(*args, **kwargs) -> typing.Any: ...
    def getMaterialAssigns(self) -> typing.List[MaterialX::MaterialAssign]: ...
    def getPropertyAssign(self, arg0: str) -> PropertyAssign: ...
    def getPropertyAssigns(self) -> typing.List[PropertyAssign]: ...
    def getPropertySetAssign(self, arg0: str) -> PropertySetAssign: ...
    def getPropertySetAssigns(self) -> typing.List[PropertySetAssign]: ...
    @staticmethod
    def getVariantAssign(*args, **kwargs) -> typing.Any: ...
    def getVariantAssigns(self) -> typing.List[MaterialX::VariantAssign]: ...
    def getVisibilities(self) -> typing.List[MaterialX::Visibility]: ...
    @staticmethod
    def getVisibility(*args, **kwargs) -> typing.Any: ...
    def removeMaterialAssign(self, arg0: str) -> None: ...
    def removePropertyAssign(self, arg0: str) -> None: ...
    def removePropertySetAssign(self, arg0: str) -> None: ...
    def removeVariantAssign(self, arg0: str) -> None: ...
    def removeVisibility(self, arg0: str) -> None: ...
    CATEGORY = 'look'
    pass
class LookGroup(Element):
    def getActiveLook(self) -> str: ...
    def getLooks(self) -> str: ...
    def setActiveLook(self, arg0: str) -> None: ...
    def setLooks(self, arg0: str) -> None: ...
    ACTIVE_ATTRIBUTE = 'active'
    CATEGORY = 'lookgroup'
    LOOKS_ATTRIBUTE = 'looks'
    pass
class MaterialAssign(GeomElement, Element):
    def getExclusive(self) -> bool: ...
    def getMaterial(self) -> str: ...
    @staticmethod
    def getReferencedMaterial(*args, **kwargs) -> typing.Any: ...
    def hasMaterial(self) -> bool: ...
    def setExclusive(self, arg0: bool) -> None: ...
    def setMaterial(self, arg0: str) -> None: ...
    CATEGORY = 'materialassign'
    pass
class MatrixBase():
    pass
class Matrix44(MatrixBase):
    def __add__(self, arg0: Matrix44) -> Matrix44: ...
    def __eq__(self, arg0: Matrix44) -> bool: ...
    def __getitem__(self, arg0: typing.Tuple[int, int]) -> float: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: float) -> None: ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: float, arg11: float, arg12: float, arg13: float, arg14: float, arg15: float) -> None: ...
    @staticmethod
    def __len__() -> int: ...
    @typing.overload
    def __mul__(self, arg0: Matrix44) -> Matrix44: ...
    @typing.overload
    def __mul__(self, arg0: float) -> Matrix44: ...
    def __ne__(self, arg0: Matrix44) -> bool: ...
    def __setitem__(self, arg0: typing.Tuple[int, int], arg1: float) -> None: ...
    def __str__(self) -> str: ...
    def __sub__(self, arg0: Matrix44) -> Matrix44: ...
    @typing.overload
    def __truediv__(self, arg0: Matrix44) -> Matrix44: ...
    @typing.overload
    def __truediv__(self, arg0: float) -> Matrix44: ...
    def copy(self) -> Matrix44: ...
    @staticmethod
    def createRotationX(arg0: float) -> Matrix44: ...
    @staticmethod
    def createRotationY(arg0: float) -> Matrix44: ...
    @staticmethod
    def createRotationZ(arg0: float) -> Matrix44: ...
    @staticmethod
    def createScale(arg0: Vector3) -> Matrix44: ...
    @staticmethod
    def createTranslation(arg0: Vector3) -> Matrix44: ...
    def getAdjugate(self) -> Matrix44: ...
    def getDeterminant(self) -> float: ...
    def getInverse(self) -> Matrix44: ...
    def getTranspose(self) -> Matrix44: ...
    def isEquivalent(self, arg0: Matrix44, arg1: float) -> bool: ...
    def multiply(self, arg0: Vector4) -> Vector4: ...
    @staticmethod
    def numColumns() -> int: ...
    @staticmethod
    def numRows() -> int: ...
    def transformNormal(self, arg0: Vector3) -> Vector3: ...
    def transformPoint(self, arg0: Vector3) -> Vector3: ...
    def transformVector(self, arg0: Vector3) -> Vector3: ...
    IDENTITY: MaterialX.PyMaterialXCore.Matrix44
    pass
class Matrix33(MatrixBase):
    def __add__(self, arg0: Matrix33) -> Matrix33: ...
    def __eq__(self, arg0: Matrix33) -> bool: ...
    def __getitem__(self, arg0: typing.Tuple[int, int]) -> float: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: float) -> None: ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float) -> None: ...
    @staticmethod
    def __len__() -> int: ...
    @typing.overload
    def __mul__(self, arg0: Matrix33) -> Matrix33: ...
    @typing.overload
    def __mul__(self, arg0: float) -> Matrix33: ...
    def __ne__(self, arg0: Matrix33) -> bool: ...
    def __setitem__(self, arg0: typing.Tuple[int, int], arg1: float) -> None: ...
    def __str__(self) -> str: ...
    def __sub__(self, arg0: Matrix33) -> Matrix33: ...
    @typing.overload
    def __truediv__(self, arg0: Matrix33) -> Matrix33: ...
    @typing.overload
    def __truediv__(self, arg0: float) -> Matrix33: ...
    def copy(self) -> Matrix33: ...
    @staticmethod
    def createRotation(arg0: float) -> Matrix33: ...
    @staticmethod
    def createScale(arg0: Vector2) -> Matrix33: ...
    @staticmethod
    def createTranslation(arg0: Vector2) -> Matrix33: ...
    def getAdjugate(self) -> Matrix33: ...
    def getDeterminant(self) -> float: ...
    def getInverse(self) -> Matrix33: ...
    def getTranspose(self) -> Matrix33: ...
    def isEquivalent(self, arg0: Matrix33, arg1: float) -> bool: ...
    def multiply(self, arg0: Vector3) -> Vector3: ...
    @staticmethod
    def numColumns() -> int: ...
    @staticmethod
    def numRows() -> int: ...
    def transformNormal(self, arg0: Vector3) -> Vector3: ...
    def transformPoint(self, arg0: Vector2) -> Vector2: ...
    def transformVector(self, arg0: Vector2) -> Vector2: ...
    IDENTITY: MaterialX.PyMaterialXCore.Matrix33
    pass
class Member(TypedElement, Element):
    CATEGORY = 'typedef'
    TYPE_ATTRIBUTE = 'type'
    pass
class Node(InterfaceElement, TypedElement, Element):
    def getConnectedNode(self, arg0: str) -> Node: ...
    def getConnectedNodeName(self, arg0: str) -> str: ...
    def getDownstreamPorts(self) -> typing.List[PortElement]: ...
    def getImplementation(self, target: str = '') -> InterfaceElement: ...
    def getNodeDef(self, target: str = '') -> NodeDef: ...
    def setConnectedNode(self, arg0: str, arg1: Node) -> None: ...
    def setConnectedNodeName(self, arg0: str, arg1: str) -> None: ...
    CATEGORY = 'node'
    NODE_DEF_ATTRIBUTE = 'nodedef'
    TYPE_ATTRIBUTE = 'type'
    pass
class NodeDef(InterfaceElement, TypedElement, Element):
    @typing.overload
    def getImplementation(self, arg0: str) -> InterfaceElement: ...
    @typing.overload
    def getImplementation(self, target: str = '') -> InterfaceElement: ...
    def getNodeGroup(self) -> str: ...
    def getNodeString(self) -> str: ...
    def hasNodeGroup(self) -> bool: ...
    def hasNodeString(self) -> bool: ...
    def isVersionCompatible(self, arg0: str) -> bool: ...
    def setNodeGroup(self, arg0: str) -> None: ...
    def setNodeString(self, arg0: str) -> None: ...
    ADJUSTMENT_NODE_GROUP = 'adjustment'
    CATEGORY = 'nodedef'
    CONDITIONAL_NODE_GROUP = 'conditional'
    GEOMETRIC_NODE_GROUP = 'geometric'
    NODE_ATTRIBUTE = 'node'
    NODE_DEF_ATTRIBUTE = 'nodedef'
    ORGANIZATION_NODE_GROUP = 'organization'
    PROCEDURAL_NODE_GROUP = 'procedural'
    TEXTURE_NODE_GROUP = 'texture'
    TYPE_ATTRIBUTE = 'type'
    pass
class NodeGraph(GraphElement, InterfaceElement, TypedElement, Element):
    def addInterfaceName(self, arg0: str, arg1: str) -> None: ...
    def getDeclaration(self, arg0: str) -> NodeDef: ...
    def getNodeDef(self) -> NodeDef: ...
    def modifyInterfaceName(self, arg0: str, arg1: str) -> None: ...
    def removeInterfaceName(self, arg0: str) -> None: ...
    def setNodeDef(self, arg0: NodeDef) -> None: ...
    CATEGORY = 'nodegraph'
    NODE_DEF_ATTRIBUTE = 'nodedef'
    TYPE_ATTRIBUTE = 'type'
    pass
class NodePredicate():
    pass
class Output(PortElement, ValueElement, TypedElement, Element):
    def hasUpstreamCycle(self) -> bool: ...
    CATEGORY = 'output'
    DEFAULT_INPUT_ATTRIBUTE = 'defaultinput'
    ENUM_ATTRIBUTE = 'enum'
    ENUM_VALUES_ATTRIBUTE = 'enumvalues'
    IMPLEMENTATION_NAME_ATTRIBUTE = 'implname'
    IMPLEMENTATION_TYPE_ATTRIBUTE = 'impltype'
    INTERFACE_NAME_ATTRIBUTE = 'interfacename'
    TYPE_ATTRIBUTE = 'type'
    UI_ADVANCED_ATTRIBUTE = 'uiadvanced'
    UI_FOLDER_ATTRIBUTE = 'uifolder'
    UI_MAX_ATTRIBUTE = 'uimax'
    UI_MIN_ATTRIBUTE = 'uimin'
    UI_NAME_ATTRIBUTE = 'uiname'
    UI_SOFT_MAX_ATTRIBUTE = 'uisoftmax'
    UI_SOFT_MIN_ATTRIBUTE = 'uisoftmin'
    UI_STEP_ATTRIBUTE = 'uistep'
    UNIT_ATTRIBUTE = 'unit'
    VALUE_ATTRIBUTE = 'value'
    pass
class Input(PortElement, ValueElement, TypedElement, Element):
    @staticmethod
    def getConnectedNode(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def getConnectedOutput(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def getDefaultGeomProp(*args, **kwargs) -> typing.Any: ...
    def getDefaultGeomPropString(self) -> str: ...
    def getInterfaceInput(self) -> Input: ...
    def hasDefaultGeomPropString(self) -> bool: ...
    @staticmethod
    def setConnectedOutput(*args, **kwargs) -> typing.Any: ...
    def setDefaultGeomPropString(self, arg0: str) -> None: ...
    CATEGORY = 'input'
    ENUM_ATTRIBUTE = 'enum'
    ENUM_VALUES_ATTRIBUTE = 'enumvalues'
    IMPLEMENTATION_NAME_ATTRIBUTE = 'implname'
    IMPLEMENTATION_TYPE_ATTRIBUTE = 'impltype'
    INTERFACE_NAME_ATTRIBUTE = 'interfacename'
    TYPE_ATTRIBUTE = 'type'
    UI_ADVANCED_ATTRIBUTE = 'uiadvanced'
    UI_FOLDER_ATTRIBUTE = 'uifolder'
    UI_MAX_ATTRIBUTE = 'uimax'
    UI_MIN_ATTRIBUTE = 'uimin'
    UI_NAME_ATTRIBUTE = 'uiname'
    UI_SOFT_MAX_ATTRIBUTE = 'uisoftmax'
    UI_SOFT_MIN_ATTRIBUTE = 'uisoftmin'
    UI_STEP_ATTRIBUTE = 'uistep'
    UNIT_ATTRIBUTE = 'unit'
    VALUE_ATTRIBUTE = 'value'
    pass
class Property(ValueElement, TypedElement, Element):
    CATEGORY = 'property'
    ENUM_ATTRIBUTE = 'enum'
    ENUM_VALUES_ATTRIBUTE = 'enumvalues'
    IMPLEMENTATION_NAME_ATTRIBUTE = 'implname'
    IMPLEMENTATION_TYPE_ATTRIBUTE = 'impltype'
    INTERFACE_NAME_ATTRIBUTE = 'interfacename'
    TYPE_ATTRIBUTE = 'type'
    UI_ADVANCED_ATTRIBUTE = 'uiadvanced'
    UI_FOLDER_ATTRIBUTE = 'uifolder'
    UI_MAX_ATTRIBUTE = 'uimax'
    UI_MIN_ATTRIBUTE = 'uimin'
    UI_NAME_ATTRIBUTE = 'uiname'
    UI_SOFT_MAX_ATTRIBUTE = 'uisoftmax'
    UI_SOFT_MIN_ATTRIBUTE = 'uisoftmin'
    UI_STEP_ATTRIBUTE = 'uistep'
    UNIT_ATTRIBUTE = 'unit'
    VALUE_ATTRIBUTE = 'value'
    pass
class PropertyAssign(ValueElement, TypedElement, Element):
    def getCollection(self) -> Collection: ...
    def getCollectionString(self) -> str: ...
    def getGeom(self) -> str: ...
    def getProperty(self) -> str: ...
    def hasCollectionString(self) -> bool: ...
    def hasGeom(self) -> bool: ...
    def hasProperty(self) -> bool: ...
    def setCollection(self, arg0: Collection) -> None: ...
    def setCollectionString(self, arg0: str) -> None: ...
    def setGeom(self, arg0: str) -> None: ...
    def setProperty(self, arg0: str) -> None: ...
    CATEGORY = 'propertyassign'
    ENUM_ATTRIBUTE = 'enum'
    ENUM_VALUES_ATTRIBUTE = 'enumvalues'
    IMPLEMENTATION_NAME_ATTRIBUTE = 'implname'
    IMPLEMENTATION_TYPE_ATTRIBUTE = 'impltype'
    INTERFACE_NAME_ATTRIBUTE = 'interfacename'
    TYPE_ATTRIBUTE = 'type'
    UI_ADVANCED_ATTRIBUTE = 'uiadvanced'
    UI_FOLDER_ATTRIBUTE = 'uifolder'
    UI_MAX_ATTRIBUTE = 'uimax'
    UI_MIN_ATTRIBUTE = 'uimin'
    UI_NAME_ATTRIBUTE = 'uiname'
    UI_SOFT_MAX_ATTRIBUTE = 'uisoftmax'
    UI_SOFT_MIN_ATTRIBUTE = 'uisoftmin'
    UI_STEP_ATTRIBUTE = 'uistep'
    UNIT_ATTRIBUTE = 'unit'
    VALUE_ATTRIBUTE = 'value'
    pass
class PropertySet(Element):
    def _getPropertyValue(self, arg0: str) -> Value: ...
    def _setPropertyValueboolean(self, name: str, value: bool, type: str = '') -> Property: ...
    def _setPropertyValuebooleanarray(self, name: str, value: typing.List[bool], type: str = '') -> Property: ...
    @staticmethod
    def _setPropertyValuecolor3(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _setPropertyValuecolor4(*args, **kwargs) -> typing.Any: ...
    def _setPropertyValuefloat(self, name: str, value: float, type: str = '') -> Property: ...
    def _setPropertyValuefloatarray(self, name: str, value: typing.List[float], type: str = '') -> Property: ...
    def _setPropertyValueinteger(self, name: str, value: int, type: str = '') -> Property: ...
    def _setPropertyValueintegerarray(self, name: str, value: typing.List[int], type: str = '') -> Property: ...
    @staticmethod
    def _setPropertyValuematrix33(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _setPropertyValuematrix44(*args, **kwargs) -> typing.Any: ...
    def _setPropertyValuestring(self, name: str, value: str, type: str = '') -> Property: ...
    def _setPropertyValuestringarray(self, name: str, value: typing.List[str], type: str = '') -> Property: ...
    @staticmethod
    def _setPropertyValuevector2(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _setPropertyValuevector3(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def _setPropertyValuevector4(*args, **kwargs) -> typing.Any: ...
    def addProperty(self, arg0: str) -> Property: ...
    def getProperties(self) -> typing.List[Property]: ...
    def removeProperty(self, arg0: str) -> None: ...
    CATEGORY = 'property'
    pass
class PropertySetAssign(GeomElement, Element):
    def getPropertySet(self) -> PropertySet: ...
    def getPropertySetString(self) -> str: ...
    def hasPropertySetString(self) -> bool: ...
    def setPropertySet(self, arg0: PropertySet) -> None: ...
    def setPropertySetString(self, arg0: str) -> None: ...
    CATEGORY = 'propertysetassign'
    pass
class StringResolver():
    def getFilePrefix(self) -> str: ...
    def getFilenameSubstitutions(self) -> typing.Dict[str, str]: ...
    def getGeomNameSubstitutions(self) -> typing.Dict[str, str]: ...
    def getGeomPrefix(self) -> str: ...
    def resolve(self, arg0: str, arg1: str) -> str: ...
    def setFilePrefix(self, arg0: str) -> None: ...
    def setFilenameSubstitution(self, arg0: str, arg1: str) -> None: ...
    def setGeomNameSubstitution(self, arg0: str, arg1: str) -> None: ...
    def setGeomPrefix(self, arg0: str) -> None: ...
    def setUdimString(self, arg0: str) -> None: ...
    def setUvTileString(self, arg0: str) -> None: ...
    pass
class Token(ValueElement, TypedElement, Element):
    CATEGORY = 'token'
    ENUM_ATTRIBUTE = 'enum'
    ENUM_VALUES_ATTRIBUTE = 'enumvalues'
    IMPLEMENTATION_NAME_ATTRIBUTE = 'implname'
    IMPLEMENTATION_TYPE_ATTRIBUTE = 'impltype'
    INTERFACE_NAME_ATTRIBUTE = 'interfacename'
    TYPE_ATTRIBUTE = 'type'
    UI_ADVANCED_ATTRIBUTE = 'uiadvanced'
    UI_FOLDER_ATTRIBUTE = 'uifolder'
    UI_MAX_ATTRIBUTE = 'uimax'
    UI_MIN_ATTRIBUTE = 'uimin'
    UI_NAME_ATTRIBUTE = 'uiname'
    UI_SOFT_MAX_ATTRIBUTE = 'uisoftmax'
    UI_SOFT_MIN_ATTRIBUTE = 'uisoftmin'
    UI_STEP_ATTRIBUTE = 'uistep'
    UNIT_ATTRIBUTE = 'unit'
    VALUE_ATTRIBUTE = 'value'
    pass
class TreeIterator():
    def __iter__(self) -> TreeIterator: ...
    def __next__(self) -> Element: ...
    def getElement(self) -> Element: ...
    def getElementDepth(self) -> int: ...
    def getPruneSubtree(self) -> bool: ...
    def setPruneSubtree(self, arg0: bool) -> None: ...
    pass
class TypeDef(Element):
    @staticmethod
    def addMember(*args, **kwargs) -> typing.Any: ...
    def getContext(self) -> str: ...
    @staticmethod
    def getMember(*args, **kwargs) -> typing.Any: ...
    def getMembers(self) -> typing.List[MaterialX::Member]: ...
    def getSemantic(self) -> str: ...
    def hasContext(self) -> bool: ...
    def hasSemantic(self) -> bool: ...
    def removeMember(self, arg0: str) -> None: ...
    def setContext(self, arg0: str) -> None: ...
    def setSemantic(self, arg0: str) -> None: ...
    CATEGORY = 'typedef'
    CONTEXT_ATTRIBUTE = 'context'
    SEMANTIC_ATTRIBUTE = 'semantic'
    pass
class Document(GraphElement, InterfaceElement, TypedElement, Element):
    def addCollection(self, name: str = '') -> Collection: ...
    def addGeomInfo(self, name: str = '', geom: str = '/') -> GeomInfo: ...
    def addGeomPropDef(self, arg0: str, arg1: str) -> GeomPropDef: ...
    def addImplementation(self, name: str = '') -> Implementation: ...
    def addLook(self, name: str = '') -> Look: ...
    def addLookGroup(self, name: str = '') -> LookGroup: ...
    def addNodeDef(self, name: str = '', type: str = 'color3', node: str = '') -> NodeDef: ...
    def addNodeDefFromGraph(self, arg0: NodeGraph, arg1: str, arg2: str, arg3: str, arg4: bool, arg5: str, arg6: str) -> NodeDef: ...
    def addNodeGraph(self, name: str = '') -> NodeGraph: ...
    def addPropertySet(self, name: str = '') -> PropertySet: ...
    def addTypeDef(self, name: str = '') -> TypeDef: ...
    def addUnitDef(self, arg0: str) -> UnitDef: ...
    def addUnitTypeDef(self, arg0: str) -> UnitTypeDef: ...
    def addVariantSet(self, name: str = '') -> VariantSet: ...
    def copy(self) -> Document: ...
    def getCollection(self, arg0: str) -> Collection: ...
    def getCollections(self) -> typing.List[Collection]: ...
    def getColorManagementConfig(self) -> str: ...
    def getColorManagementSystem(self) -> str: ...
    def getGeomInfo(self, arg0: str) -> GeomInfo: ...
    def getGeomInfos(self) -> typing.List[GeomInfo]: ...
    def getGeomPropDef(self, arg0: str) -> GeomPropDef: ...
    def getGeomPropDefs(self) -> typing.List[GeomPropDef]: ...
    def getGeomPropValue(self, geomPropName: str, geom: str = '/') -> Value: ...
    def getImplementation(self, arg0: str) -> Implementation: ...
    def getImplementations(self) -> typing.List[Implementation]: ...
    def getLook(self, arg0: str) -> Look: ...
    def getLookGroup(self, arg0: str) -> LookGroup: ...
    def getLookGroups(self) -> typing.List[LookGroup]: ...
    def getLooks(self) -> typing.List[Look]: ...
    def getMatchingImplementations(self, arg0: str) -> typing.List[InterfaceElement]: ...
    def getMatchingNodeDefs(self, arg0: str) -> typing.List[NodeDef]: ...
    def getMatchingPorts(self, arg0: str) -> typing.List[PortElement]: ...
    def getNodeDef(self, arg0: str) -> NodeDef: ...
    def getNodeDefs(self) -> typing.List[NodeDef]: ...
    def getNodeGraph(self, arg0: str) -> NodeGraph: ...
    def getNodeGraphs(self) -> typing.List[NodeGraph]: ...
    def getPropertySet(self, arg0: str) -> PropertySet: ...
    def getPropertySets(self) -> typing.List[PropertySet]: ...
    def getReferencedSourceUris(self) -> typing.Set[str]: ...
    def getTypeDef(self, arg0: str) -> TypeDef: ...
    def getTypeDefs(self) -> typing.List[TypeDef]: ...
    def getUnitDef(self, arg0: str) -> UnitDef: ...
    def getUnitDefs(self) -> typing.List[UnitDef]: ...
    def getUnitTypeDef(self, arg0: str) -> UnitTypeDef: ...
    def getUnitTypeDefs(self) -> typing.List[UnitTypeDef]: ...
    def getVariantSet(self, arg0: str) -> VariantSet: ...
    def getVariantSets(self) -> typing.List[VariantSet]: ...
    def hasColorManagementConfig(self) -> bool: ...
    def hasColorManagementSystem(self) -> bool: ...
    def importLibrary(self, arg0: Document) -> None: ...
    def initialize(self) -> None: ...
    def removeCollection(self, arg0: str) -> None: ...
    def removeGeomInfo(self, arg0: str) -> None: ...
    def removeGeomPropDef(self, arg0: str) -> None: ...
    def removeImplementation(self, arg0: str) -> None: ...
    def removeLook(self, arg0: str) -> None: ...
    def removeLookGroup(self, arg0: str) -> None: ...
    def removeNodeDef(self, arg0: str) -> None: ...
    def removeNodeGraph(self, arg0: str) -> None: ...
    def removePropertySet(self, arg0: str) -> None: ...
    def removeTypeDef(self, arg0: str) -> None: ...
    def removeUnitDef(self, arg0: str) -> None: ...
    def removeUnitTypeDef(self, arg0: str) -> None: ...
    def removeVariantSet(self, arg0: str) -> None: ...
    def setColorManagementConfig(self, arg0: str) -> None: ...
    def setColorManagementSystem(self, arg0: str) -> None: ...
    def upgradeVersion(self) -> None: ...
    NODE_DEF_ATTRIBUTE = 'nodedef'
    TYPE_ATTRIBUTE = 'type'
    pass
class Value():
    @staticmethod
    def createValueFromStrings(arg0: str, arg1: str) -> Value: ...
    def getTypeString(self) -> str: ...
    def getValueString(self) -> str: ...
    pass
class TypedValue_booleanarray(Value):
    @staticmethod
    def createValue(arg0: typing.List[bool]) -> Value: ...
    def getData(self) -> typing.List[bool]: ...
    def getValueString(self) -> str: ...
    TYPE = 'booleanarray'
    pass
class TypedValue_color3(Value):
    @staticmethod
    def createValue(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def getData(*args, **kwargs) -> typing.Any: ...
    def getValueString(self) -> str: ...
    TYPE = 'color3'
    pass
class TypedValue_color4(Value):
    @staticmethod
    def createValue(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def getData(*args, **kwargs) -> typing.Any: ...
    def getValueString(self) -> str: ...
    TYPE = 'color4'
    pass
class TypedValue_float(Value):
    @staticmethod
    def createValue(arg0: float) -> Value: ...
    def getData(self) -> float: ...
    def getValueString(self) -> str: ...
    TYPE = 'float'
    pass
class TypedValue_floatarray(Value):
    @staticmethod
    def createValue(arg0: typing.List[float]) -> Value: ...
    def getData(self) -> typing.List[float]: ...
    def getValueString(self) -> str: ...
    TYPE = 'floatarray'
    pass
class TypedValue_integer(Value):
    @staticmethod
    def createValue(arg0: int) -> Value: ...
    def getData(self) -> int: ...
    def getValueString(self) -> str: ...
    TYPE = 'integer'
    pass
class TypedValue_integerarray(Value):
    @staticmethod
    def createValue(arg0: typing.List[int]) -> Value: ...
    def getData(self) -> typing.List[int]: ...
    def getValueString(self) -> str: ...
    TYPE = 'integerarray'
    pass
class TypedValue_matrix33(Value):
    @staticmethod
    def createValue(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def getData(*args, **kwargs) -> typing.Any: ...
    def getValueString(self) -> str: ...
    TYPE = 'matrix33'
    pass
class TypedValue_matrix44(Value):
    @staticmethod
    def createValue(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def getData(*args, **kwargs) -> typing.Any: ...
    def getValueString(self) -> str: ...
    TYPE = 'matrix44'
    pass
class TypedValue_string(Value):
    @staticmethod
    def createValue(arg0: str) -> Value: ...
    def getData(self) -> str: ...
    def getValueString(self) -> str: ...
    TYPE = 'string'
    pass
class TypedValue_stringarray(Value):
    @staticmethod
    def createValue(arg0: typing.List[str]) -> Value: ...
    def getData(self) -> typing.List[str]: ...
    def getValueString(self) -> str: ...
    TYPE = 'stringarray'
    pass
class TypedValue_vector2(Value):
    @staticmethod
    def createValue(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def getData(*args, **kwargs) -> typing.Any: ...
    def getValueString(self) -> str: ...
    TYPE = 'vector2'
    pass
class TypedValue_vector3(Value):
    @staticmethod
    def createValue(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def getData(*args, **kwargs) -> typing.Any: ...
    def getValueString(self) -> str: ...
    TYPE = 'vector3'
    pass
class TypedValue_vector4(Value):
    @staticmethod
    def createValue(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def getData(*args, **kwargs) -> typing.Any: ...
    def getValueString(self) -> str: ...
    TYPE = 'vector4'
    pass
class Unit(Element):
    CATEGORY = 'unit'
    pass
class LinearUnitConverter(UnitConverter):
    @typing.overload
    def convert(self, arg0: Vector2, arg1: str, arg2: str) -> Vector2: ...
    @typing.overload
    def convert(self, arg0: Vector3, arg1: str, arg2: str) -> Vector3: ...
    @typing.overload
    def convert(self, arg0: Vector4, arg1: str, arg2: str) -> Vector4: ...
    @typing.overload
    def convert(self, arg0: float, arg1: str, arg2: str) -> float: ...
    @staticmethod
    def create(arg0: UnitTypeDef) -> LinearUnitConverter: ...
    def getUnitAsInteger(self, arg0: str) -> int: ...
    def getUnitFromInteger(self, arg0: int) -> str: ...
    def getUnitScale(self) -> typing.Dict[str, float]: ...
    pass
class UnitConverterRegistry():
    def addUnitConverter(self, arg0: UnitTypeDef, arg1: UnitConverter) -> bool: ...
    def clearUnitConverters(self) -> None: ...
    @staticmethod
    def create() -> UnitConverterRegistry: ...
    def getUnitConverter(self, arg0: UnitTypeDef) -> UnitConverter: ...
    def removeUnitConverter(self, arg0: UnitTypeDef) -> bool: ...
    pass
class UnitDef(Element):
    def addUnit(self, arg0: str) -> Unit: ...
    def getUnit(self, arg0: str) -> Unit: ...
    def getUnitType(self) -> str: ...
    def getUnits(self) -> typing.List[Unit]: ...
    def hasUnitType(self) -> bool: ...
    def setUnitType(self) -> bool: ...
    CATEGORY = 'unitdef'
    UNITTYPE_ATTRIBUTE = 'unittype'
    pass
class UnitTypeDef(Element):
    def getUnitDefs(self) -> typing.List[UnitDef]: ...
    CATEGORY = 'unittypedef'
    pass
class TypedValue_boolean(Value):
    @staticmethod
    def createValue(arg0: bool) -> Value: ...
    def getData(self) -> bool: ...
    def getValueString(self) -> str: ...
    TYPE = 'boolean'
    pass
class GeomProp(ValueElement, TypedElement, Element):
    CATEGORY = 'geomprop'
    ENUM_ATTRIBUTE = 'enum'
    ENUM_VALUES_ATTRIBUTE = 'enumvalues'
    IMPLEMENTATION_NAME_ATTRIBUTE = 'implname'
    IMPLEMENTATION_TYPE_ATTRIBUTE = 'impltype'
    INTERFACE_NAME_ATTRIBUTE = 'interfacename'
    TYPE_ATTRIBUTE = 'type'
    UI_ADVANCED_ATTRIBUTE = 'uiadvanced'
    UI_FOLDER_ATTRIBUTE = 'uifolder'
    UI_MAX_ATTRIBUTE = 'uimax'
    UI_MIN_ATTRIBUTE = 'uimin'
    UI_NAME_ATTRIBUTE = 'uiname'
    UI_SOFT_MAX_ATTRIBUTE = 'uisoftmax'
    UI_SOFT_MIN_ATTRIBUTE = 'uisoftmin'
    UI_STEP_ATTRIBUTE = 'uistep'
    UNIT_ATTRIBUTE = 'unit'
    VALUE_ATTRIBUTE = 'value'
    pass
class Variant(InterfaceElement, TypedElement, Element):
    CATEGORY = 'variant'
    NODE_DEF_ATTRIBUTE = 'nodedef'
    TYPE_ATTRIBUTE = 'type'
    pass
class VariantAssign(Element):
    def getVariantSetString(self) -> str: ...
    def getVariantString(self) -> str: ...
    def hasVariantSetString(self) -> bool: ...
    def hasVariantString(self) -> bool: ...
    def setVariantSetString(self, arg0: str) -> None: ...
    def setVariantString(self, arg0: str) -> None: ...
    CATEGORY = 'variantassign'
    pass
class VariantSet(Element):
    def addVariant(self, name: str = '') -> Variant: ...
    def getVariant(self, arg0: str) -> Variant: ...
    def getVariants(self) -> typing.List[Variant]: ...
    def removeVariant(self, arg0: str) -> None: ...
    CATEGORY = 'variantset'
    pass
class Vector2(VectorBase):
    def __add__(self, arg0: Vector2) -> Vector2: ...
    def __eq__(self, arg0: Vector2) -> bool: ...
    def __getitem__(self, arg0: int) -> float: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: float) -> None: ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float) -> None: ...
    @typing.overload
    def __init__(self, arg0: typing.List[float[2]]) -> None: ...
    @typing.overload
    def __init__(self, arg0: typing.List[float]) -> None: ...
    @staticmethod
    def __len__() -> int: ...
    @typing.overload
    def __mul__(self, arg0: Vector2) -> Vector2: ...
    @typing.overload
    def __mul__(self, arg0: float) -> Vector2: ...
    def __ne__(self, arg0: Vector2) -> bool: ...
    def __setitem__(self, arg0: int, arg1: float) -> None: ...
    def __str__(self) -> str: ...
    def __sub__(self, arg0: Vector2) -> Vector2: ...
    @typing.overload
    def __truediv__(self, arg0: Vector2) -> Vector2: ...
    @typing.overload
    def __truediv__(self, arg0: float) -> Vector2: ...
    def asTuple(self) -> typing.Tuple[float, float]: ...
    def copy(self) -> Vector2: ...
    def cross(self, arg0: Vector2) -> float: ...
    def dot(self, arg0: Vector2) -> float: ...
    def getMagnitude(self) -> float: ...
    def getNormalized(self) -> Vector2: ...
    pass
class Vector3(VectorBase):
    def __add__(self, arg0: Vector3) -> Vector3: ...
    def __eq__(self, arg0: Vector3) -> bool: ...
    def __getitem__(self, arg0: int) -> float: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: float) -> None: ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: float) -> None: ...
    @typing.overload
    def __init__(self, arg0: typing.List[float[3]]) -> None: ...
    @typing.overload
    def __init__(self, arg0: typing.List[float]) -> None: ...
    @staticmethod
    def __len__() -> int: ...
    @typing.overload
    def __mul__(self, arg0: Vector3) -> Vector3: ...
    @typing.overload
    def __mul__(self, arg0: float) -> Vector3: ...
    def __ne__(self, arg0: Vector3) -> bool: ...
    def __setitem__(self, arg0: int, arg1: float) -> None: ...
    def __str__(self) -> str: ...
    def __sub__(self, arg0: Vector3) -> Vector3: ...
    @typing.overload
    def __truediv__(self, arg0: Vector3) -> Vector3: ...
    @typing.overload
    def __truediv__(self, arg0: float) -> Vector3: ...
    def asTuple(self) -> typing.Tuple[float, float, float]: ...
    def copy(self) -> Vector3: ...
    def cross(self, arg0: Vector3) -> Vector3: ...
    def dot(self, arg0: Vector3) -> float: ...
    def getMagnitude(self) -> float: ...
    def getNormalized(self) -> Vector3: ...
    pass
class Vector4(VectorBase):
    def __add__(self, arg0: Vector4) -> Vector4: ...
    def __eq__(self, arg0: Vector4) -> bool: ...
    def __getitem__(self, arg0: int) -> float: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: float) -> None: ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float) -> None: ...
    @typing.overload
    def __init__(self, arg0: typing.List[float[4]]) -> None: ...
    @typing.overload
    def __init__(self, arg0: typing.List[float]) -> None: ...
    @staticmethod
    def __len__() -> int: ...
    @typing.overload
    def __mul__(self, arg0: Vector4) -> Vector4: ...
    @typing.overload
    def __mul__(self, arg0: float) -> Vector4: ...
    def __ne__(self, arg0: Vector4) -> bool: ...
    def __setitem__(self, arg0: int, arg1: float) -> None: ...
    def __str__(self) -> str: ...
    def __sub__(self, arg0: Vector4) -> Vector4: ...
    @typing.overload
    def __truediv__(self, arg0: Vector4) -> Vector4: ...
    @typing.overload
    def __truediv__(self, arg0: float) -> Vector4: ...
    def asTuple(self) -> typing.Tuple[float, float, float, float]: ...
    def copy(self) -> Vector4: ...
    def dot(self, arg0: Vector4) -> float: ...
    def getMagnitude(self) -> float: ...
    def getNormalized(self) -> Vector4: ...
    pass
class Color3(VectorBase):
    def __add__(self, arg0: Color3) -> Color3: ...
    def __eq__(self, arg0: Color3) -> bool: ...
    def __getitem__(self, arg0: int) -> float: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: float) -> None: ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: float) -> None: ...
    @typing.overload
    def __init__(self, arg0: typing.List[float[3]]) -> None: ...
    @typing.overload
    def __init__(self, arg0: typing.List[float]) -> None: ...
    @staticmethod
    def __len__() -> int: ...
    @typing.overload
    def __mul__(self, arg0: Color3) -> Color3: ...
    @typing.overload
    def __mul__(self, arg0: float) -> Color3: ...
    def __ne__(self, arg0: Color3) -> bool: ...
    def __setitem__(self, arg0: int, arg1: float) -> None: ...
    def __str__(self) -> str: ...
    def __sub__(self, arg0: Color3) -> Color3: ...
    @typing.overload
    def __truediv__(self, arg0: Color3) -> Color3: ...
    @typing.overload
    def __truediv__(self, arg0: float) -> Color3: ...
    def asTuple(self) -> typing.Tuple[float, float, float]: ...
    def copy(self) -> Color3: ...
    def dot(self, arg0: Color3) -> float: ...
    def getMagnitude(self) -> float: ...
    def getNormalized(self) -> Color3: ...
    pass
class Visibility(GeomElement, Element):
    def getViewerCollection(self) -> str: ...
    def getViewerGeom(self) -> str: ...
    def getVisibilityType(self) -> str: ...
    def getVisible(self) -> bool: ...
    def hasViewerCollection(self) -> bool: ...
    def hasViewerGeom(self) -> bool: ...
    def hasVisibilityType(self) -> bool: ...
    def setViewerCollection(self, arg0: str) -> None: ...
    def setViewerGeom(self, arg0: str) -> None: ...
    def setVisibilityType(self, arg0: str) -> None: ...
    def setVisible(self, arg0: bool) -> None: ...
    CATEGORY = 'visibility'
    pass
def createDocument(*args, **kwargs) -> typing.Any:
    pass
def createNamePath(arg0: typing.List[str]) -> str:
    pass
def createValidName(name: str, replaceChar: str = '_') -> str:
    pass
def geomStringsMatch(arg0: str, arg1: str, arg2: bool) -> bool:
    pass
def getConnectedOutputs(arg0: Node) -> typing.List[Output]:
    pass
def getGeometryBindings(*args, **kwargs) -> typing.Any:
    pass
def getShaderNodes(materialNode: Node, nodeType: str = 'surfaceshader', target: str = '') -> typing.Set[Node]:
    pass
def getVersionIntegers() -> typing.Tuple[int, int, int]:
    pass
def getVersionString() -> str:
    pass
def incrementName(arg0: str) -> str:
    pass
def isValidName(arg0: str) -> bool:
    pass
def parentNamePath(arg0: str) -> str:
    pass
def prettyPrint(arg0: Element) -> str:
    pass
def replaceSubstrings(arg0: str, arg1: typing.Dict[str, str]) -> str:
    pass
def splitNamePath(arg0: str) -> typing.List[str]:
    pass
def splitString(arg0: str, arg1: str) -> typing.List[str]:
    pass
def stringEndsWith(arg0: str, arg1: str) -> bool:
    pass
def targetStringsMatch(arg0: str, arg1: str) -> bool:
    pass
ARRAY_PREFERRED_SEPARATOR = ', '
ARRAY_VALID_SEPARATORS = ', '
DEFAULT_TYPE_STRING = 'color3'
DISPLACEMENT_SHADER_TYPE_STRING = 'displacementshader'
FILENAME_TYPE_STRING = 'filename'
GEOMNAME_TYPE_STRING = 'geomname'
LIGHT_SHADER_TYPE_STRING = 'lightshader'
MATERIAL_TYPE_STRING = 'material'
MULTI_OUTPUT_TYPE_STRING = 'multioutput'
NAME_PATH_SEPARATOR = '/'
NAME_PREFIX_SEPARATOR = ':'
NONE_TYPE_STRING = 'none'
SURFACE_MATERIAL_NODE_STRING = 'surfacematerial'
SURFACE_SHADER_TYPE_STRING = 'surfaceshader'
VALUE_STRING_FALSE = 'false'
VALUE_STRING_TRUE = 'true'
VOLUME_MATERIAL_NODE_STRING = 'volumematerial'
VOLUME_SHADER_TYPE_STRING = 'volumeshader'
